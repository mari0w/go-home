<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Golang如何操作excel</title>
      <link href="2020/10/11/golang/excel/"/>
      <url>2020/10/11/golang/excel/</url>
      
        <content type="html"><![CDATA[<h3 id="关键术语介绍"><a href="#关键术语介绍" class="headerlink" title="关键术语介绍"></a>关键术语介绍</h3><p>为了方便开源库的快速上手，我们先来了解 excel 中的几个关键术语，如下图所示，①为sheet，也就是表格中的页签；②为row，代表 excel 中的一行；③为cell，代表 excel 中的一个单元格。</p><p><img src="http://pingyeaa.oss-cn-shenzhen.aliyuncs.com/image-1602348679727.png" alt=""></p><p>正常情况下，创建一个表格的基本流程是打开 wps 点击新建，这时会默认创建一个 sheet，然后在该 sheet 中的第一行填写表头，接下来根据表头逐行填充内容，最后将文件另存为到硬盘的某个位置。其实我们利用 Golang 的开源库创建 excel 时也是如此，下面我们来创建一个简易的表格。</p><h3 id="创建表格"><a href="#创建表格" class="headerlink" title="创建表格"></a>创建表格</h3><p>创建表格前需要先引入 excel 库，我们以比较热门的 <strong>tealeg/xlsx</strong> 库为例。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/tealeg/xlsx</span><br></pre></td></tr></table></figure><p>首先创建一个空文件，拿到文件句柄。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file := xlsx.NewFile()</span><br></pre></td></tr></table></figure><p>创建一个名为<code>人员信息收集</code>的 sheet。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sheet, err := file.AddSheet(<span class="string">"人员信息收集"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后为该 sheet 创建一行，这行作为我们的表头。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">row := sheet.AddRow()</span><br></pre></td></tr></table></figure><p>在该行中创建一个单元格。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cell := row.AddCell()</span><br></pre></td></tr></table></figure><p>现在给单元格填充内容，因为是表头，暂且叫<code>姓名</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cell.Value = <span class="string">"姓名"</span></span><br></pre></td></tr></table></figure><p>如何创建第二个单元格呢？原理相同，此处 cell 变量已定义，再创建新单元格只需赋值即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cell = row.AddCell()</span><br><span class="line">cell.Value = <span class="string">"性别"</span></span><br></pre></td></tr></table></figure><p>表头已经设置好了，可以开始创建第二行来填充内容了，方式与上述无差别。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">row = sheet.AddRow()</span><br><span class="line">cell = row.AddCell()</span><br><span class="line">cell.Value = <span class="string">"张三"</span></span><br><span class="line">cell = row.AddCell()</span><br><span class="line">cell.Value = <span class="string">"男"</span></span><br></pre></td></tr></table></figure><p>表格设置完成后，将该文件保存，文件名可自定义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err = file.Save(<span class="string">"demo.xlsx"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跑起来后，可以发现目录中多了一个 demo.xlsx 文件，打开预览内容如下，达到了预期效果。</p><p><img src="http://pingyeaa.oss-cn-shenzhen.aliyuncs.com/image-1602403048980.png" alt=""></p><p><strong>文件源码</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"github.com/tealeg/xlsx"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">file := xlsx.NewFile()</span><br><span class="line">sheet, err := file.AddSheet(<span class="string">"人员信息收集"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">row := sheet.AddRow()</span><br><span class="line">cell := row.AddCell()</span><br><span class="line">cell.Value = <span class="string">"姓名"</span></span><br><span class="line">cell = row.AddCell()</span><br><span class="line">cell.Value = <span class="string">"性别"</span></span><br><span class="line"></span><br><span class="line">row = sheet.AddRow()</span><br><span class="line">cell = row.AddCell()</span><br><span class="line">cell.Value = <span class="string">"张三"</span></span><br><span class="line">cell = row.AddCell()</span><br><span class="line">cell.Value = <span class="string">"男"</span></span><br><span class="line"></span><br><span class="line">err = file.Save(<span class="string">"demo.xlsx"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取表格"><a href="#读取表格" class="headerlink" title="读取表格"></a>读取表格</h3><p>表格的读取比创建简单很多，依然以上文创建的文件为例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output, err := xlsx.FileToSlice(<span class="string">"demo.xlsx"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需将文件路径传入上述方法，即可自动读取并返回一个三维切片，我们来读取第一个 sheet 的第二行中的第一个单元格。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.Println(output[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>]) <span class="comment">//Output: 男</span></span><br></pre></td></tr></table></figure><p>由此一来就非常容易遍历了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> rowIndex, row := <span class="keyword">range</span> output[<span class="number">0</span>] &#123;</span><br><span class="line">  <span class="keyword">for</span> cellIndex, cell := <span class="keyword">range</span> row &#123;</span><br><span class="line">    log.Println(fmt.Sprintf(<span class="string">"第%d行，第%d个单元格：%s"</span>, rowIndex+<span class="number">1</span>, cellIndex+<span class="number">1</span>, cell))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span>/<span class="number">10</span>/<span class="number">11</span> <span class="number">16</span>:<span class="number">15</span>:<span class="number">29</span> 第<span class="number">1</span>行，第<span class="number">1</span>个单元格：姓名</span><br><span class="line"><span class="number">2020</span>/<span class="number">10</span>/<span class="number">11</span> <span class="number">16</span>:<span class="number">15</span>:<span class="number">29</span> 第<span class="number">1</span>行，第<span class="number">2</span>个单元格：性别</span><br><span class="line"><span class="number">2020</span>/<span class="number">10</span>/<span class="number">11</span> <span class="number">16</span>:<span class="number">15</span>:<span class="number">29</span> 第<span class="number">2</span>行，第<span class="number">1</span>个单元格：张三</span><br><span class="line"><span class="number">2020</span>/<span class="number">10</span>/<span class="number">11</span> <span class="number">16</span>:<span class="number">15</span>:<span class="number">29</span> 第<span class="number">2</span>行，第<span class="number">2</span>个单元格：男</span><br></pre></td></tr></table></figure><p><strong>文件源码</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/tealeg/xlsx"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">output, err := xlsx.FileToSlice(<span class="string">"demo.xlsx"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">log.Println(output[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line"><span class="keyword">for</span> rowIndex, row := <span class="keyword">range</span> output[<span class="number">0</span>] &#123;</span><br><span class="line"><span class="keyword">for</span> cellIndex, cell := <span class="keyword">range</span> row &#123;</span><br><span class="line">log.Println(fmt.Sprintf(<span class="string">"第%d行，第%d个单元格：%s"</span>, rowIndex+<span class="number">1</span>, cellIndex+<span class="number">1</span>, cell))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改表格"><a href="#修改表格" class="headerlink" title="修改表格"></a>修改表格</h3><p>只是读取表格内容可能在特定场景下无法满足需求，有时候需要对表格内容进行更改。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file, err := xlsx.OpenFile(<span class="string">"demo.xlsx"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改表格之前依然需要先读取文件，只是这次并没有直接将其转化为三维切片。拿到文件句柄后，可以直接修改某一行的内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.Sheets[<span class="number">0</span>].Rows[<span class="number">1</span>].Cells[<span class="number">0</span>].Value = <span class="string">"李四"</span></span><br></pre></td></tr></table></figure><p>上述代码将第二行的张三改为了李四，但这还没有结束，接下来需要将文件重新保存。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err = file.Save(<span class="string">"demo.xlsx"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开文件预览，可以看到已经成功将张三改为了李四。</p><p><img src="http://pingyeaa.oss-cn-shenzhen.aliyuncs.com/image-1602405538334.png" alt=""></p><p><strong>文件源码</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"github.com/tealeg/xlsx"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">file, err := xlsx.OpenFile(<span class="string">"demo.xlsx"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">file.Sheets[<span class="number">0</span>].Rows[<span class="number">1</span>].Cells[<span class="number">0</span>].Value = <span class="string">"李四"</span></span><br><span class="line">err = file.Save(<span class="string">"demo.xlsx"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="样式设置"><a href="#样式设置" class="headerlink" title="样式设置"></a>样式设置</h3><p>该开源库不仅支持内容的编辑，还支持表格的样式设置，样式统一由结构体 Style 来负责。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Style <span class="keyword">struct</span> &#123;</span><br><span class="line">Border          Border</span><br><span class="line">Fill            Fill</span><br><span class="line">Font            Font</span><br><span class="line">ApplyBorder     <span class="keyword">bool</span></span><br><span class="line">ApplyFill       <span class="keyword">bool</span></span><br><span class="line">ApplyFont       <span class="keyword">bool</span></span><br><span class="line">ApplyAlignment  <span class="keyword">bool</span></span><br><span class="line">Alignment       Alignment</span><br><span class="line">NamedStyleIndex *<span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿上述生成的文件为例，假如我要将姓名所在单元格居中，首先要实例化样式对象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">style := xlsx.NewStyle()</span><br></pre></td></tr></table></figure><p>赋值居中属性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">style.Alignment = xlsx.Alignment&#123;</span><br><span class="line">  Horizontal:   <span class="string">"center"</span>,</span><br><span class="line">  Vertical:     <span class="string">"center"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给第一行第一个单元格设置样式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.Sheets[<span class="number">0</span>].Rows[<span class="number">0</span>].Cells[<span class="number">0</span>].SetStyle(style)</span><br></pre></td></tr></table></figure><p>与修改表格处理逻辑相同，最后保存文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err = file.Save(<span class="string">"demo.xlsx"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开预览，可以看到文字已经上下左右居中。</p><p><img src="http://pingyeaa.oss-cn-shenzhen.aliyuncs.com/image-1602413052099.png" alt=""></p><p>同理，可以修改文字颜色和背景，同样通过 style 的属性来设置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">style.Font.Color = xlsx.RGB_Dark_Red</span><br><span class="line">style.Fill.BgColor = xlsx.RGB_Dark_Green</span><br></pre></td></tr></table></figure><p><img src="http://pingyeaa.oss-cn-shenzhen.aliyuncs.com/image-1602413398061.png" alt=""></p><p>其他还有很多属性可以设置，比如合并单元格、字体、大小等等，大家可以自行测试。</p><p><strong>文件源码</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"github.com/tealeg/xlsx"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">file, err := xlsx.OpenFile(<span class="string">"demo.xlsx"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">style := xlsx.NewStyle()</span><br><span class="line">style.Font.Color = xlsx.RGB_Dark_Red</span><br><span class="line">style.Fill.BgColor = xlsx.RGB_Dark_Green</span><br><span class="line">style.Alignment = xlsx.Alignment&#123;</span><br><span class="line">Horizontal:   <span class="string">"center"</span>,</span><br><span class="line">Vertical:     <span class="string">"center"</span>,</span><br><span class="line">&#125;</span><br><span class="line">file.Sheets[<span class="number">0</span>].Rows[<span class="number">0</span>].Cells[<span class="number">0</span>].SetStyle(style)</span><br><span class="line">err = file.Save(<span class="string">"demo.xlsx"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> excel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>API 网关 Kong</title>
      <link href="2020/05/16/architecture/gateway-kong/"/>
      <url>2020/05/16/architecture/gateway-kong/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-API-网关？"><a href="#什么是-API-网关？" class="headerlink" title="什么是 API 网关？"></a>什么是 API 网关？</h2><p>所谓网关，主要作用就是连接两个不同网络的设备，而今天所讲的 API 网关是指承接和分发客户端所有请求的网关层。</p><p><img src="https://pingyeaa.oss-cn-shenzhen.aliyuncs.com/image-1589604854331.png" alt=""></p><p>为什么需要网关层？最初是单体服务时，客户端发起的所有请求都可以直接请求到该服务，但随着产品用户越来越多，单体应用存在显而易见的单点问题，除此之外，当单体应用大小升至几个 G 时，持续发布将会非常缓慢，所以服务的拆分成为了必然趋势。</p><p><img src="https://pingyeaa.oss-cn-shenzhen.aliyuncs.com/image-1589605857758.png" alt=""></p><p>当服务拆分为多个之后，我们不得不面临一个问题，就是如何控制用户请求到对应服务节点，于是网关层应运而生，它不仅可以负责负载均衡，还可以让它处理认证校验、请求限流、日志记录以及监控服务节点等等。</p><p><img src="https://pingyeaa.oss-cn-shenzhen.aliyuncs.com/image-1589606854321.png" alt=""></p><p>当然，网关层并不需要我们手动实现，市面上有很多 API 网关开源项目，比如 Zuul、Kong、Tyk 等，今天主要介绍 Kong。</p><h2 id="安装-Kong"><a href="#安装-Kong" class="headerlink" title="安装 Kong"></a>安装 Kong</h2><p>Kong 是一个在 Nginx 中运行的 Lua 程序，由 lua-nginx-module 实现，和 Openresty 一起打包发行，支持多种操作环境下的安装，可以用来做 HTTP 基本认证、密钥认证、TCP、UDP、文件日志、API 请求限流、请求转发等等。</p><p>第一步，创建一个 docker 网络。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create kong-net</span><br></pre></td></tr></table></figure><p>创建用于存储 Kong 数据的数据库，可以使用 Cassandra 或 PostgreSQL，本示例采用 Cassandra。</p><blockquote><p>Cassandra 是由 Facebook 开发的分布式 NoSQL 数据库。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name kong-database \</span><br><span class="line">               --network=kong-net \</span><br><span class="line">               -p 9042:9042 \</span><br><span class="line">               cassandra:3</span><br></pre></td></tr></table></figure><p>初始化数据到 Cassandra 数据库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm \</span><br><span class="line">--network=kong-net \</span><br><span class="line">-e <span class="string">"KONG_DATABASE=cassandra"</span> \</span><br><span class="line">-e <span class="string">"KONG_PG_HOST=kong-database"</span> \</span><br><span class="line">-e <span class="string">"KONG_PG_PASSWORD=kong"</span> \</span><br><span class="line">-e <span class="string">"KONG_CASSANDRA_CONTACT_POINTS=kong-database"</span> \</span><br><span class="line">kong:latest kong migrations bootstrap</span><br></pre></td></tr></table></figure><p>启动 Kong 容器连接数据库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name kong \</span><br><span class="line">    --network=kong-net \</span><br><span class="line">    -e <span class="string">"KONG_DATABASE=cassandra"</span> \</span><br><span class="line">    -e <span class="string">"KONG_PG_HOST=kong-database"</span> \</span><br><span class="line">    -e <span class="string">"KONG_PG_PASSWORD=kong"</span> \</span><br><span class="line">    -e <span class="string">"KONG_CASSANDRA_CONTACT_POINTS=kong-database"</span> \</span><br><span class="line">    -e <span class="string">"KONG_PROXY_ACCESS_LOG=/dev/stdout"</span> \</span><br><span class="line">    -e <span class="string">"KONG_ADMIN_ACCESS_LOG=/dev/stdout"</span> \</span><br><span class="line">    -e <span class="string">"KONG_PROXY_ERROR_LOG=/dev/stderr"</span> \</span><br><span class="line">    -e <span class="string">"KONG_ADMIN_ERROR_LOG=/dev/stderr"</span> \</span><br><span class="line">    -e <span class="string">"KONG_ADMIN_LISTEN=0.0.0.0:8001, 0.0.0.0:8444 ssl"</span> \</span><br><span class="line">    -p 8000:8000 \</span><br><span class="line">    -p 8443:8443 \</span><br><span class="line">    -p 0.0.0.0:8001:8001 \</span><br><span class="line">    -p 0.0.0.0:8444:8444 \</span><br><span class="line">    kong:latest</span><br></pre></td></tr></table></figure><p>通过 curl 模拟请求本地 8001 端口可以获取 Kong 的详细信息。截止目前整个 kong 服务就跑起来了，接下来可以注册服务节点到 kong 中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i http://localhost:8001/</span><br></pre></td></tr></table></figure><h2 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h2><p>注册名为 baidu-service 的服务到 kong，如果请求匹配到该服务会跳转至 url。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i -X POST \</span><br><span class="line">  --url http://localhost:8001/services/ \</span><br><span class="line">  --data <span class="string">'name=baidu-service'</span> \</span><br><span class="line">  --data <span class="string">'url=http://baidu.com'</span></span><br></pre></td></tr></table></figure><p>注册成功之后会得到如下提示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 201 Created</span><br><span class="line">Date: Sat, 16 May 2020 06:35:56 GMT</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Server: kong/2.0.4</span><br><span class="line">Content-Length: 292</span><br><span class="line">X-Kong-Admin-Latency: 103</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">"host"</span>:<span class="string">"baidu.com"</span>,<span class="string">"created_at"</span>:1589610956,<span class="string">"connect_timeout"</span>:60000,<span class="string">"id"</span>:<span class="string">"6660aaa7-5afa-4f02-85f8-11dfb81fba84"</span>,<span class="string">"protocol"</span>:<span class="string">"http"</span>,<span class="string">"name"</span>:<span class="string">"baidu-service"</span>,<span class="string">"read_timeout"</span>:60000,<span class="string">"port"</span>:80,<span class="string">"path"</span>:null,<span class="string">"updated_at"</span>:1589610956,<span class="string">"retries"</span>:5,<span class="string">"write_timeout"</span>:60000,<span class="string">"tags"</span>:null,<span class="string">"client_certificate"</span>:null&#125;</span><br></pre></td></tr></table></figure><h2 id="服务配置路由"><a href="#服务配置路由" class="headerlink" title="服务配置路由"></a>服务配置路由</h2><p>服务添加成功后，需要告知 kong 什么样的请求才使用该服务，而这个规则被称为 route，也就是路由，路由的作用是按规则匹配客户端的请求，然后转发到对应的 service，每个 route 都对应一个 service，一个 service 可能有多个 route。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i -X POST \</span><br><span class="line">  --url http://localhost:8001/services/baidu-service/routes \</span><br><span class="line">  --data <span class="string">'hosts[]=baidu.com'</span></span><br></pre></td></tr></table></figure><p>以上代码的作用是当请求域名是 baidu.com 时，则将请求转发到 baidu-service 指定的 url，我们可以通过 curl 模拟测试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i -X GET \</span><br><span class="line">  --url http://localhost:8000/ \</span><br><span class="line">  --header <span class="string">'Host: baidu.com'</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Content-Length: 81</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Date: Sat, 16 May 2020 06:45:12 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT</span><br><span class="line">ETag: <span class="string">"51-47cf7e6ee8400"</span></span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Cache-Control: max-age=86400</span><br><span class="line">Expires: Sun, 17 May 2020 06:45:12 GMT</span><br><span class="line">X-Kong-Upstream-Latency: 92</span><br><span class="line">X-Kong-Proxy-Latency: 17</span><br><span class="line">Via: kong/2.0.4</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"refresh"</span> content=<span class="string">"0;url=http://www.baidu.com/"</span>&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="负载均衡配置"><a href="#负载均衡配置" class="headerlink" title="负载均衡配置"></a>负载均衡配置</h2><p>与 nginx 同理，先创建一个 upstream，名为 hello。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X POST http://localhost:8001/upstreams --data <span class="string">"name=hello"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"created_at"</span>:1589633009,<span class="string">"hash_on"</span>:<span class="string">"none"</span>,<span class="string">"id"</span>:<span class="string">"3bab80bb-7e62-40c8-8b7c-7efdcc329675"</span>,<span class="string">"algorithm"</span>:<span class="string">"round-robin"</span>,<span class="string">"name"</span>:<span class="string">"hello"</span>,<span class="string">"tags"</span>:null,<span class="string">"hash_fallback_header"</span>:null,<span class="string">"hash_fallback"</span>:<span class="string">"none"</span>,<span class="string">"hash_on_cookie"</span>:null,<span class="string">"host_header"</span>:null,<span class="string">"hash_on_cookie_path"</span>:<span class="string">"\/"</span>,<span class="string">"healthchecks"</span>:&#123;<span class="string">"threshold"</span>:0,<span class="string">"active"</span>:&#123;<span class="string">"https_verify_certificate"</span>:<span class="literal">true</span>,<span class="string">"type"</span>:<span class="string">"http"</span>,<span class="string">"http_path"</span>:<span class="string">"\/"</span>,<span class="string">"timeout"</span>:1,<span class="string">"unhealthy"</span>:&#123;<span class="string">"http_statuses"</span>:[429,404,500,501,502,503,504,505],<span class="string">"tcp_failures"</span>:0,<span class="string">"timeouts"</span>:0,<span class="string">"http_failures"</span>:0,<span class="string">"interval"</span>:0&#125;,<span class="string">"healthy"</span>:&#123;<span class="string">"http_statuses"</span>:[200,302],<span class="string">"interval"</span>:0,<span class="string">"successes"</span>:0&#125;,<span class="string">"https_sni"</span>:null,<span class="string">"concurrency"</span>:10&#125;,<span class="string">"passive"</span>:&#123;<span class="string">"unhealthy"</span>:&#123;<span class="string">"http_failures"</span>:0,<span class="string">"http_statuses"</span>:[429,500,503],<span class="string">"tcp_failures"</span>:0,<span class="string">"timeouts"</span>:0&#125;,<span class="string">"healthy"</span>:&#123;<span class="string">"http_statuses"</span>:[200,201,202,203,204,205,206,207,208,226,300,301,302,303,304,305,306,307,308],<span class="string">"successes"</span>:0&#125;,<span class="string">"type"</span>:<span class="string">"http"</span>&#125;&#125;,<span class="string">"hash_on_header"</span>:null,<span class="string">"slots"</span>:10000&#125;</span><br></pre></td></tr></table></figure><p>为 upstream 添加两个负载均衡的节点，我就拿京东和淘宝来做测试了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://localhost:8001/upstreams/hello/targets --data <span class="string">"target=jd.com"</span> --data <span class="string">"weight=100"</span></span><br><span class="line">curl -X POST http://localhost:8001/upstreams/hello/targets --data <span class="string">"target=taobao.com"</span> --data <span class="string">"weight=50"</span></span><br></pre></td></tr></table></figure><p>如上配置就相当于 nginx 中的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream hello &#123;</span><br><span class="line">server jd.com weight=100;</span><br><span class="line">server taobao.com weight=50;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来创建一个 service 指向 upstream，host 即对应 upstream 名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://localhost:8001/services --data <span class="string">"name=hello"</span> --data <span class="string">"host=hello"</span></span><br></pre></td></tr></table></figure><p>为 service 创建路由，凡是包含 /hello 的地址全部走 hello upstream。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -i -X POST --url http://localhost:8001/services/hello/routes --data <span class="string">'paths[]=/hello'</span></span><br><span class="line">curl -X POST --url http://localhost:8001/routes --data <span class="string">'paths[]=/hello'</span> --data <span class="string">'service.id=8ad06aa5-be0a-4763-a84d-90b8046765f5'</span></span><br></pre></td></tr></table></figure><p>现在访问 localhost:8000 就可以看到已经成功做了负载均衡。</p><h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>因为服务器不能处理无限量的请求，为了避免请求数高到服务器无法处理，必须做限流操作。关于限流，kong 使用了 rate-limiting 插件，它可以在 service、route、consumer 不同粒度上控制请求，配置非常简单。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://kong:8001/services/&#123;service&#125;/plugins \</span><br><span class="line">    --data <span class="string">"name=rate-limiting"</span></span><br><span class="line">    --data <span class="string">"config.second=5"</span> \</span><br><span class="line">    --data <span class="string">"config.hour=10000"</span></span><br></pre></td></tr></table></figure><p>config.second 代表一秒钟内处理的最大请求次数，config.hour 表示一小时内最大请求次数。</p><p>Route 的示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://kong:8001/routes/&#123;route&#125;/plugins \</span><br><span class="line">    --data <span class="string">"name=rate-limiting"</span></span><br><span class="line">    --data <span class="string">"config.second=5"</span> \</span><br><span class="line">    --data <span class="string">"config.hour=10000"</span></span><br></pre></td></tr></table></figure><p>Consumer 的示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://kong:8001/consumers/&#123;consumer&#125;/plugins \</span><br><span class="line">    --data <span class="string">"name=rate-limiting-advanced"</span> \</span><br><span class="line">    --data <span class="string">"config.second=5"</span> \</span><br><span class="line">    --data <span class="string">"config.hour=10000"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
          <category> 网关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网关 </tag>
            
            <tag> kong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用 frp 实现内网穿透</title>
      <link href="2020/05/13/network/frp/"/>
      <url>2020/05/13/network/frp/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>作为一名程序员，家里多多少少会有一些落了灰的电脑，如果把闲置的电脑变成服务器，不仅有良好的配置，还能用来做各种测试，那就再好不过了。但是局域网的设备怎么被外网访问呢？这就靠内网穿透来实现了。</p><p>内网穿透又叫 <a href="#nat">NAT</a> 穿透，常用的工具有很多，比如 ngrok、花生壳、frp等，因为我使用的是 frp，这也是本篇文章的主题。</p><p><span id="nat"></span></p><blockquote><p>NAT 是在 IP 数据包通过路由器或防火墙的时候重写 IP 地址的技术。因为现在的公网 IP 数量有限，国家不能给每个设备分配一个公网 IP，所以只能多台计算机共用一个公网 IP 对外通讯，这样就需要进行网络转换，而 NAT 的目的正是如此。</p></blockquote><h2 id="基本实现原理"><a href="#基本实现原理" class="headerlink" title="基本实现原理"></a>基本实现原理</h2><p>frp 分为服务端与客户端，前者运行在有公网 IP 的服务器上，后者运行在局域网内的设备上，服务端默认会先开放 7000 端口，然后客户端与其相连。</p><p><img src="https://pingyeaa.oss-cn-shenzhen.aliyuncs.com/image-1589543547681.png" alt=""></p><p>同时客户端可以开启用于 ssh 的端口，与服务端的某个端口做映射，这样我们在终端访问服务端的端口时，会自动转发到客户端去。</p><p><img src="https://pingyeaa.oss-cn-shenzhen.aliyuncs.com/image-1589544730493.png" alt=""></p><p>除了 ssh 端口之外，frp 还支持 web 端口来接收 http 访问。</p><h2 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h2><p>目前需要公网服务器、内网服务器各一台，我的内网服务器重装了 linux 系统，方便试验各类工具。</p><h3 id="服务端安装配置"><a href="#服务端安装配置" class="headerlink" title="服务端安装配置"></a>服务端安装配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.33.0/frp_0.33.0_linux_amd64.tar.gz</span><br><span class="line">tar zxvf frp_0.33.0_linux_amd64.tar.gz</span><br><span class="line">cd frp_0.33.0_linux_amd64/</span><br></pre></td></tr></table></figure><p>服务端的配置文件是 frps.ini，默认绑定 7000 端口，如果购置了云服务器，注意打开 7000 端口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br></pre></td></tr></table></figure><p>通过 fprs 二进制文件启动 frp 服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frps -c ./frps.ini</span><br></pre></td></tr></table></figure><p>如下提示即是安装成功。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2020/05/15 22:16:29 [I] [service.go:178] frps tcp listen on 0.0.0.0:7000</span><br><span class="line">2020/05/15 22:16:29 [I] [root.go:209] start frps success</span><br><span class="line">2020/05/15 22:16:38 [I] [service.go:432] [e3c5096bd4291972] client login info: ip [14.114.230.168:44422] version [0.24.1] hostname [] os [linux] arch [amd64]</span><br><span class="line">2020/05/15 22:16:38 [I] [tcp.go:63] [e3c5096bd4291972] [ssh] tcp proxy listen port [7001]</span><br><span class="line">2020/05/15 22:16:38 [I] [control.go:445] [e3c5096bd4291972] new proxy [ssh] success</span><br></pre></td></tr></table></figure><h3 id="客户端安装配置"><a href="#客户端安装配置" class="headerlink" title="客户端安装配置"></a>客户端安装配置</h3><p>把自己的破电脑拿出来，以同样的方式下载 frp。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.33.0/frp_0.33.0_linux_amd64.tar.gz</span><br><span class="line">tar zxvf frp_0.33.0_linux_amd64.tar.gz</span><br><span class="line">cd frp_0.33.0_linux_amd64/</span><br></pre></td></tr></table></figure><p>客户端的配置文件是 frpc.ini。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = 127.0.0.1</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line">[ssh]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 22</span><br><span class="line">remote_port = 6000</span><br></pre></td></tr></table></figure><p>common 为通用配置</p><ul><li>server_addr 为公网服务器 IP 地址</li><li>server_port 为公网服务器配置的 7000 端口</li></ul><p>ssh 用于终端命令行访问</p><ul><li>type 连接类型，默认为 tcp</li><li>local_ip 本地  IP</li><li>local_port 用于 ssh 的端口号，默认 22</li><li>remote_port 映射的服务端端口，访问该端口时默认转发到客户端的 22 端口</li></ul><p>启动客户端进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frpc -c ./frpc.ini</span><br></pre></td></tr></table></figure><p>如有以下提示则代表与服务端连接成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2020/05/15 22:34:49 [I] [service.go:282] [9bc650122a538aab] login to server success, get run id [9bc650122a538aab], server udp port [0]</span><br><span class="line">2020/05/15 22:34:49 [I] [proxy_manager.go:144] [9bc650122a538aab] proxy added: [ssh]</span><br><span class="line">2020/05/15 22:34:49 [I] [control.go:179] [9bc650122a538aab] [ssh] start proxy success</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>启动完成后就可以通过 ssh 连接到内网服务器了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 6000 enoch@xxx.xx.xxx.xxx</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> frp </tag>
            
            <tag> 内网穿透 </tag>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程管理工具 Supervisor</title>
      <link href="2020/04/23/os/supervisor/"/>
      <url>2020/04/23/os/supervisor/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我是平也，这有一个专注Gopher技术成长的开源项目<a href="https://github.com/pingyeaa/go-home" target="_blank" rel="noopener">「go home」</a></p></blockquote><p>要想在终端后台常驻进程，首先想到的是在命令后加 &amp; 符号，来达到隐藏程序在后台的目的，尽管看起来进程已经在后台运行了，实际上终端会话关闭时进程还是会被 kill 掉，这种问题一般是采用搭配 nohup 命令来解决的，nohup 作用是忽略 SIGHUP 信号，而会话关闭时正好发送了该信号给会话内所有运行程序，简而言之，nohup 命令搭配 &amp; 不仅可以在后台运行，还不受会话关闭的影响。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nohup /bin/cat &amp;</span></span><br></pre></td></tr></table></figure><p><img src="https://pingyeaa.oss-cn-shenzhen.aliyuncs.com/image-1587648951163.png" alt="file"></p><p>那么问题来了，虽然做到了后台运行，也避免了挂断操作带来的影响，但是它避免不了常驻进程自己出现问题，一旦它因自身异常终止了进程，这对黄金搭档就无力回天了。那怎么才能把挂了的常驻进程拉起来呢？这就是我们要讲的主题 Supervisor。</p><h3 id="Supervisor-介绍"><a href="#Supervisor-介绍" class="headerlink" title="Supervisor 介绍"></a>Supervisor 介绍</h3><p>Supervisor 是专门用来在<a href="#unix">类 Unix</a> 系统上监控管理进程的工具，发布于 2004 年，虽然名字气势磅礴，但它的志向并不是统筹整个操作系统的进程，而是致力于做一个听话的贴身助理，你只需要告诉它要管理的程序，它就按你的要求监控进程，救死扶伤，保证进程的持续运行。</p><p><img src="https://pingyeaa.oss-cn-shenzhen.aliyuncs.com/image-1587649424854.png" alt="file"></p><p><span id="unix"></span></p><blockquote><p>类 Unix 系统就是由 Unix 设计风格演变出的操作系统，除了 Windows 市面上绝大多数系统都是类 Unix 系统。</p></blockquote><p>官方文档介绍 Supervisor 是 C/S 架构体系，它对应的角色分别为 Supervisorctl 和 Supervisord。后者的主要作用是启动配置好的程序、响应 Supervisorctl 发过来的指令以及重启退出的子进程，而前者是 Supervisor 的客户端，它以命令行的形式提供了一系列参数，来方便用户向 Supervisord 发送指令，常用的有启动、暂停、移除、更新等命令。</p><h3 id="Supervisor-安装与配置"><a href="#Supervisor-安装与配置" class="headerlink" title="Supervisor 安装与配置"></a>Supervisor 安装与配置</h3><p>安装 Supervisor 很简单，在各大操作系统的软件包管理器中都可以直接安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum install -y supervisor</span></span><br></pre></td></tr></table></figure><p>安装好的 Supervisor 配置文件默认为 /etc/supervisor.conf，如果找不到配置文件可以<a href="#gen_conf">通过官方命令生成</a>，该配置文件包含了一个空的配置目录 /etc/supervisor.d（不同 OS 可能不一样），只需在该目录添加配置文件即可动态扩展，所以 supervisor.conf 一般不需要做改动。</p><p>我们以最简单的 cat 命令为例，cat 命令不加参数会阻塞住等待标准输入，所以很适合做常驻进程的演示。现在创建一个配置文件 cat.ini 到 /etc/supervisor.d/，第一行定义程序的名称，该名称用来做操作的标识，第二行定义命令路径，它才是程序执行的根本命令。</p><figure class="highlight shell"><figcaption><span>/etc/supervisor.d/cat.ini</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[program:foo]</span><br><span class="line">command=/bin/cat</span><br></pre></td></tr></table></figure><p>配置好后，启动 supervisord 服务，注意通过 -c 指定 supervisor 的配置文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> supervisord -c /etc/supervisord.conf</span></span><br></pre></td></tr></table></figure><p>当然也可以不指定配置路径，那么它会按以下顺序逐个搜索配置文件：</p><ul><li>$CWD/supervisord.conf</li><li>$CWD/etc/supervisord.conf</li><li>/etc/supervisord.conf</li><li>/etc/supervisor/supervisord.conf</li><li>../etc/supervisord.conf</li><li>../supervisord.conf</li></ul><p><span id="gen_conf"></span></p><p>如果你是通过 Mac OS 安装的 Supervisor，可能从上述目录都找不到配置文件，可以利用官方提供的命令生成配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> echo_supervisord_conf &gt; supervisor.conf</span></span><br></pre></td></tr></table></figure><p>这个时候 cat 进程应该已经跑起来了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps aux | grep /bin/cat</span></span><br></pre></td></tr></table></figure><p>杀掉进程，进程 id 会发生变化，证明 supervisor 又把 cat 拉了起来。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo <span class="built_in">kill</span> 9 &lt;进程ID&gt;</span></span><br></pre></td></tr></table></figure><h3 id="核心配置讲解"><a href="#核心配置讲解" class="headerlink" title="核心配置讲解"></a>核心配置讲解</h3><p>配置文件中的选项并不止 command，官方提供了很多配置项。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[program:name]</span></span><br><span class="line"><span class="attr">command</span>=sh /tmp/echo_time.sh</span><br><span class="line"><span class="attr">priority</span>=<span class="number">999</span></span><br><span class="line"><span class="attr">numprocs</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">autostart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">autorestart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">startsecs</span>=<span class="number">10</span></span><br><span class="line"><span class="attr">startretries</span>=<span class="number">3</span> </span><br><span class="line"><span class="attr">exitcodes</span>=<span class="number">0</span>,<span class="number">2</span></span><br><span class="line"><span class="attr">stopsignal</span>=QUIT</span><br><span class="line"><span class="attr">stopwaitsecs</span>=<span class="number">10</span></span><br><span class="line"><span class="attr">user</span>=root</span><br><span class="line"><span class="attr">log_stdout</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">log_stderr</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">logfile</span>=/tmp/echo_time.log</span><br><span class="line"><span class="attr">logfile_maxbytes</span>=<span class="number">1</span>MB</span><br><span class="line"><span class="attr">logfile_backups</span>=<span class="number">10</span> </span><br><span class="line"><span class="attr">stdout_logfile_maxbytes</span>=<span class="number">20</span>MB </span><br><span class="line"><span class="attr">stdout_logfile_backups</span>=<span class="number">20</span> </span><br><span class="line"><span class="attr">stdout_logfile</span>=/tmp/echo_time.stdout.log</span><br></pre></td></tr></table></figure><p>下面挑选几个配置简要说明</p><ul><li>command：要执行的命令</li><li>priority：执行优先级，值越高就越晚启动，越早关闭</li><li>numprocs：进程数量</li><li>autostart：是否与 supervisord 一起启动</li><li>autorestart：自动重启</li><li>startsecs：延时启动时间，默认为 10 秒</li><li>startretries：启动重试次数，默认为 3 次</li><li>exitcodes：当程序的退出码为 0 或 2 时，重启</li><li>stopsignal：停止信号</li><li>stopwaitsecs：延时停止时间，收到停止指令后多久停止</li><li>user：以哪个用户执行</li></ul><h3 id="动态操作子程序"><a href="#动态操作子程序" class="headerlink" title="动态操作子程序"></a>动态操作子程序</h3><p>添加新的程序，只需增加配置文件，然后执行 supervisorctl update 即可动态添加新的程序，并不需要重启 supervisord 服务。如果出现 refused connection 的提示，可能是没找到配置文件，需要加上配置选项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> supervisorctl update</span></span><br><span class="line">foo1: added process group</span><br></pre></td></tr></table></figure><p>删除同理，remove 时会先将进程关闭，再从列表中移除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo1: stopped</span><br><span class="line">foo1: removed process group</span><br></pre></td></tr></table></figure><p>如果需要单独停止某个程序，可以使用 stop 命令，stop 后跟的是 program 名称。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> supervisorctl stop foo</span></span><br><span class="line">foo: stopped</span><br></pre></td></tr></table></figure><p>当然还可以通过 stop all 命令更加暴力的停止所有进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> supervisorctl stop all</span></span><br><span class="line">foo: stopped</span><br><span class="line">foo1: stopped</span><br></pre></td></tr></table></figure><p>反之亦然，启动进程只需要将 stop 改为 start。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> supervisorctl start all</span></span><br></pre></td></tr></table></figure><h4 id="连接到某个进程"><a href="#连接到某个进程" class="headerlink" title="连接到某个进程"></a>连接到某个进程</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> supervisorctl <span class="built_in">fg</span> &lt;program 名称&gt;</span></span><br></pre></td></tr></table></figure><h4 id="重启-supervisord"><a href="#重启-supervisord" class="headerlink" title="重启 supervisord"></a>重启 supervisord</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> supervisorctl reload</span></span><br></pre></td></tr></table></figure><h4 id="动态加载-supervisor-conf"><a href="#动态加载-supervisor-conf" class="headerlink" title="动态加载 supervisor.conf"></a>动态加载 supervisor.conf</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> supervisorctl reread</span></span><br></pre></td></tr></table></figure><h4 id="查看所有进程运行状况"><a href="#查看所有进程运行状况" class="headerlink" title="查看所有进程运行状况"></a>查看所有进程运行状况</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> supervisorctl status</span></span><br></pre></td></tr></table></figure><h3 id="Web-界面操作"><a href="#Web-界面操作" class="headerlink" title="Web 界面操作"></a>Web 界面操作</h3><p>官方提供了界面操作方式，需要在 supervisor.conf 中去掉 inet_http_server 的注释。</p><figure class="highlight ini"><figcaption><span>supervisor.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[inet_http_server]</span>         <span class="comment">; inet (TCP) server disabled by default</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9001</span>        <span class="comment">; ip_address:port specifier, *:port for all iface</span></span><br><span class="line"><span class="attr">username</span>=user              <span class="comment">; default is no username (open server)</span></span><br><span class="line"><span class="attr">password</span>=<span class="number">123</span>               <span class="comment">; default is no password (open server)</span></span><br></pre></td></tr></table></figure><p>重启 supervisord。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> supervisorctl reload</span></span><br></pre></td></tr></table></figure><p>访问 <a href="http://localhost:9001" target="_blank" rel="noopener">http://localhost:9001</a> 可以看到 supervisor 的操作界面。</p><p><img src="https://pingyeaa.oss-cn-shenzhen.aliyuncs.com/image-1587696070630.png" alt="file"></p><p>今天文章就到这里，想要了解更多，欢迎查看<a href="http://supervisord.org/" target="_blank" rel="noopener">官方文档</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> supervisor </tag>
            
            <tag> 进程 </tag>
            
            <tag> 监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何用Github钩子做自动部署</title>
      <link href="2020/04/22/other/github-webhooks/"/>
      <url>2020/04/22/other/github-webhooks/</url>
      
        <content type="html"><![CDATA[<p>最近机缘巧合的购置了域名和服务器，不用实在是浪费，再加上一直没有属于自己的个人网站，所以打算用hexo在服务器上玩一下，这样也就不用再纠结用Github pages还是Gitee pages了。当然，今天的主题并不是博客搭建，而是如何利用Github的钩子，将博客代码部署到服务器上。</p><p>毕竟Github的钩子已经历史悠久了，网上有很多开源项目可以拿来用，所以我并没有造轮子，而是去找了5K star的开源Go项目<code>webhook</code>，这个工具的作用是接收Github仓库的变动通知，然后调用你配置好的shell脚本，脚本可以写上代码拉取的命令或是编译的操作等，具体根据个人需求而定。简而言之，它只起着拉通Github与你服务器的作用。</p><p><img src="https://pingyeaa.oss-cn-shenzhen.aliyuncs.com/image-1587526481705.png" alt="file"></p><h3 id="webhook工具安装"><a href="#webhook工具安装" class="headerlink" title="webhook工具安装"></a>webhook工具安装</h3><p>因为webhook是Go语言开发的，所以要先安装Go语言。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y golang</span><br></pre></td></tr></table></figure><p>然后就可以用go命令安装webhook了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/adnanh/webhook</span><br></pre></td></tr></table></figure><p>命令安装位置可以通过<code>go env</code>查看，GOPATH就是命令安装路径，比如我的命令就安装在/root/go/bin/webhook。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go env</span><br><span class="line">...</span><br><span class="line">GOOS="linux"</span><br><span class="line">GOPATH="/root/go"</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="生成ssh-key"><a href="#生成ssh-key" class="headerlink" title="生成ssh key"></a>生成ssh key</h3><p>在编写脚本之前确保服务器有权限拉取github代码，如果已经做了配置可跳过本节去看<a href="#部署脚本编写">部署脚本编写</a>。ssh key是代码托管平台（github、gitee、coding、gitlab等）鉴别你是否有权拉取代码的身份标识，生成只需一行命令和一路回车就行了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br><span class="line"></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/root/.ssh/id_rsa): </span><br><span class="line">Enter passphrase (empty for no passphrase): </span><br><span class="line">Enter same passphrase again: </span><br><span class="line">Your identification has been saved in /root/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /root/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:M6sCf/J/hOu3zLxMkFUVmv3iWIa30CfbxiWqmWCt1YE root@iZwz96y36tk2ecnykzituxZ</span><br><span class="line">The key's randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">|            ..o. |</span><br><span class="line">|           . o   |</span><br><span class="line">|          . o    |</span><br><span class="line">|       . o .     |</span><br><span class="line">|      E S.  .    |</span><br><span class="line">|  .  . ..Oo ..   |</span><br><span class="line">|   oo o ==Boo .  |</span><br><span class="line">|   .++.+o#== .   |</span><br><span class="line">|    .=*+=+@o     |</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure><p>生成后可通过<code>cat ~/.ssh/id_rsa.pub</code>命令查看，最后将key加入github即可，加法不再赘述，请自行谷歌。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br><span class="line"></span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQHBAAABAQCv7LGVJUFdcLL+HZyRFTQIQCdre61Gch76lDVpmWSX9BGGRU3iQS7EU5qApFn1VSvt+yf4rMt2LEkuxGCm1wIyBKZ6LYDViZBeTAfx4BcM1mcpxOX6I/+r07mQ4llTz+poQB1Zp9Y60uk0tbGOVWlCoDBEvf9qeEnQ0qEczEkv7wcawV6pVhlXjFKZgq0EOQbCYoWMvPUl+dwDbTcl/h+7At1nlgfF7IuRHlKf18qvgnTRT2wpiuz4pWdoAi8LcY1JiR1z5OB0oCJ2euhyDND39G2NxZRS1FIVdgCEvioHtdoHOSoWBlcSj0fLFSnscBfRBrCd7yhOP7fFKfrowHMj root@iZwz96y36tk2ecnykzituxZ</span><br></pre></td></tr></table></figure><h3 id="部署脚本编写"><a href="#部署脚本编写" class="headerlink" title="部署脚本编写"></a>部署脚本编写</h3><p>该shell脚本的主要目的是从github拉取代码，脚本内容很简单，只做了目录的简要判断，代码目录存在则更新，不存在则克隆仓库，工作目录和仓库名称、地址请换成自己的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">cd /home/www/website</span><br><span class="line"></span><br><span class="line">if [ ! -d "go-home" ]; then</span><br><span class="line">  git clone https://github.com/pingyeaa/go-home.git</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">cd go-home</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><h3 id="webhook配置与启动"><a href="#webhook配置与启动" class="headerlink" title="webhook配置与启动"></a>webhook配置与启动</h3><p>编写配置文件hooks.json，格式如下。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="string">"deploy-webhook"</span>,</span><br><span class="line">    <span class="attr">"execute-command"</span>: <span class="string">"deploy.sh"</span>,</span><br><span class="line">    <span class="attr">"command-working-directory"</span>: <span class="string">"/home"</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>id：钩子的id，可自定义</li><li>execute-command：要执行的脚本名，就是刚才编写的部署脚本</li><li>command-working-directory：脚本所在目录</li></ul><p>完成后通过webhook命令启动，可以看到id为deploy-webhook的配置已经加载了，我们需要注意的是监听的端口和路径，等下要用到。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/root/go/bin/webhook -hooks hooks.json -verbose</span><br><span class="line"></span><br><span class="line">[webhook] 2020/04/22 15:18:22 version 2.6.11 starting</span><br><span class="line">[webhook] 2020/04/22 15:18:22 setting up os signal watcher</span><br><span class="line">[webhook] 2020/04/22 15:18:22 attempting to load hooks from hooks.json</span><br><span class="line">[webhook] 2020/04/22 15:18:22 found 1 hook(s) in file</span><br><span class="line">[webhook] 2020/04/22 15:18:22   loaded: deploy-webhook</span><br><span class="line">[webhook] 2020/04/22 15:18:22 serving hooks on http://0.0.0.0:9000/hooks/&#123;id&#125;</span><br><span class="line">[webhook] 2020/04/22 15:18:22 os signal watcher ready</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://0.0.0.0:9000/hooks/&#123;id&#125;</span><br></pre></td></tr></table></figure><h3 id="Github-Webhooks配置"><a href="#Github-Webhooks配置" class="headerlink" title="Github Webhooks配置"></a>Github Webhooks配置</h3><p>现在服务器已经启动了webhook程序监听9000端口，接下来仅需要告诉Github这个地址和端口就好了。</p><p>打开仓库设置页，添加webhook。</p><p><img src="https://pingyeaa.oss-cn-shenzhen.aliyuncs.com/image-1587523289550.png" alt=""></p><p>配置webhooks，Payload URL就是要通知的地址，把刚才打印出的端口和路径填上即可，其他默认。</p><p><img src="https://pingyeaa.oss-cn-shenzhen.aliyuncs.com/image-1587541102651.png" alt="file"></p><p>现在可以提交代码测试了，如果推送失败Github中会有错误提示，同样的，成功不仅在Github中能看到，服务器的打印日志也有记录。</p><p><img src="https://pingyeaa.oss-cn-shenzhen.aliyuncs.com/image-1587541394355.png" alt="file"></p><p><img src="https://pingyeaa.oss-cn-shenzhen.aliyuncs.com/image-1587541482026.png" alt="file"></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> webhooks </tag>
            
            <tag> 钩子 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
